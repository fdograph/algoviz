{"ast":null,"code":"export const delay = t => new Promise(r => setTimeout(r, t));\nexport const delayMethod = async (method, t) => {\n  await method();\n  await delay(t);\n};\nexport const updateAt = (source, idx, val) => {\n  const updated = [...source];\n  updated.splice(idx, 1, val);\n  return updated;\n};\nexport const swap = (base, target, source) => {\n  const result = [...source];\n  [result[base], result[target]] = [result[target], result[base]];\n  return result;\n};\nexport const arrayToMap = list => new Map(list.map((v, idx) => [idx, v]));\nexport const splitMap = map => {\n  const half = Math.ceil(map.size / 2);\n  const entries = [...map.entries()];\n  const parts = {\n    left: new Map(),\n    right: new Map()\n  };\n  entries.forEach((_ref, entryIdx) => {\n    let [idx, val] = _ref;\n\n    if (entryIdx < half) {\n      parts.left.set(idx, val);\n    } else {\n      parts.right.set(idx, val);\n    }\n  });\n  return parts;\n};\nexport const updateSortedMap = (map, sorted) => {\n  const entries = [...map.entries()];\n  const sortedMap = new Map();\n  entries.forEach((_ref2, eIdx) => {\n    let [oIdx, eVal] = _ref2;\n    sortedMap.set(oIdx, sorted[eIdx]);\n  });\n  return sortedMap;\n};\nexport const buildRandomList = size => {\n  return [...new Array(size)].map((n, idx) => idx + 1).sort(() => Math.random() > 0.5 ? 1 : -1);\n};\nexport const graduallyInsertEntries = async (map, list, setRenderList, setSelectedIdxs, interval) => {\n  let resultList = [...list];\n\n  for (const [idx, val] of map.entries()) {\n    const updatedList = updateAt(resultList, idx, val);\n    setSelectedIdxs(new Set([idx]));\n    setRenderList(updatedList);\n    resultList = updatedList;\n    await delay(interval);\n  }\n\n  return resultList;\n};\nexport const insertEntries = (map, list) => {\n  let resultList = [...list];\n\n  for (const [idx, val] of map.entries()) {\n    resultList = updateAt(resultList, idx, val);\n  }\n\n  return resultList;\n};\nexport const listsAreEqual = (l1, l2) => {\n  return l1.join(\"\") === l2.join(\"\");\n};\nlet KILL_SWITCH = false;\nexport const resetKillSwitch = () => {\n  KILL_SWITCH = false;\n};\nexport const enableKillSwitch = () => {\n  KILL_SWITCH = true;\n};\nexport const checkKillSwitch = () => {\n  if (KILL_SWITCH) {\n    throw new Error(\"Algorithm was paused or killed\");\n  }\n};\nexport const onSortStep = (originalList, setRenderList, setSelectedIdxs, interval) => {\n  return async list => {\n    await delayMethod(() => {\n      setSelectedIdxs(new Set([...list.keys()]));\n    }, interval);\n    const newList = insertEntries(list, originalList);\n\n    if (!listsAreEqual(newList, originalList)) {\n      originalList = await graduallyInsertEntries(list, originalList, setRenderList, setSelectedIdxs, interval);\n    }\n  };\n};","map":{"version":3,"sources":["/Users/fernandosilva/projects/algoviz/src/logic/utils.ts"],"names":["delay","t","Promise","r","setTimeout","delayMethod","method","updateAt","source","idx","val","updated","splice","swap","base","target","result","arrayToMap","list","Map","map","v","splitMap","half","Math","ceil","size","entries","parts","left","right","forEach","entryIdx","set","updateSortedMap","sorted","sortedMap","eIdx","oIdx","eVal","buildRandomList","Array","n","sort","random","graduallyInsertEntries","setRenderList","setSelectedIdxs","interval","resultList","updatedList","Set","insertEntries","listsAreEqual","l1","l2","join","KILL_SWITCH","resetKillSwitch","enableKillSwitch","checkKillSwitch","Error","onSortStep","originalList","keys","newList"],"mappings":"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","sourcesContent":["import { VisualAlgoControl } from \"./algorithms\";\n\nexport type BaseAlgoFn = (\n  list: Map<number, number>,\n  onSortStep: (list: Map<number, number>) => Promise<void>\n) => Promise<Map<number, number>>;\n\nexport type VisualAlgoFn = (\n  originalList: number[],\n  setRenderList: (l: number[]) => void,\n  setSelectedIdxs: (idxs: Set<number>) => void\n) => VisualAlgoControl;\n\nexport const delay = (t: number) => new Promise((r) => setTimeout(r, t));\n\nexport const delayMethod = async (\n  method: () => Promise<void> | void,\n  t: number\n) => {\n  await method();\n  await delay(t);\n};\n\nexport const updateAt = (\n  source: Readonly<number[]>,\n  idx: number,\n  val: number\n) => {\n  const updated = [...source];\n  updated.splice(idx, 1, val);\n\n  return updated;\n};\n\nexport const swap = (base: number, target: number, source: number[]) => {\n  const result = [...source];\n\n  [result[base], result[target]] = [result[target], result[base]];\n\n  return result;\n};\n\nexport const arrayToMap = (list: number[]): Map<number, number> =>\n  new Map(list.map((v, idx) => [idx, v]));\n\nexport const splitMap = (map: Map<number, number>) => {\n  const half = Math.ceil(map.size / 2);\n  const entries = [...map.entries()];\n  const parts = {\n    left: new Map<number, number>(),\n    right: new Map<number, number>(),\n  };\n\n  entries.forEach(([idx, val], entryIdx) => {\n    if (entryIdx < half) {\n      parts.left.set(idx, val);\n    } else {\n      parts.right.set(idx, val);\n    }\n  });\n\n  return parts;\n};\n\nexport const updateSortedMap = (map: Map<number, number>, sorted: number[]) => {\n  const entries = [...map.entries()];\n  const sortedMap = new Map<number, number>();\n\n  entries.forEach(([oIdx, eVal], eIdx) => {\n    sortedMap.set(oIdx, sorted[eIdx]);\n  });\n\n  return sortedMap;\n};\n\nexport const buildRandomList = (size: number) => {\n  return [...new Array(size)]\n    .map((n, idx) => idx + 1)\n    .sort(() => (Math.random() > 0.5 ? 1 : -1));\n};\n\nexport const graduallyInsertEntries = async (\n  map: Map<number, number>,\n  list: number[],\n  setRenderList: (l: number[]) => void,\n  setSelectedIdxs: (idxs: Set<number>) => void,\n  interval: number\n) => {\n  let resultList = [...list];\n\n  for (const [idx, val] of map.entries()) {\n    const updatedList = updateAt(resultList, idx, val);\n    setSelectedIdxs(new Set<number>([idx]));\n    setRenderList(updatedList);\n    resultList = updatedList;\n\n    await delay(interval);\n  }\n\n  return resultList;\n};\n\nexport const insertEntries = (map: Map<number, number>, list: number[]) => {\n  let resultList = [...list];\n\n  for (const [idx, val] of map.entries()) {\n    resultList = updateAt(resultList, idx, val);\n  }\n\n  return resultList;\n};\n\nexport const listsAreEqual = (l1: number[], l2: number[]): boolean => {\n  return l1.join(\"\") === l2.join(\"\");\n};\n\nlet KILL_SWITCH = false;\nexport const resetKillSwitch = () => {\n  KILL_SWITCH = false;\n};\n\nexport const enableKillSwitch = () => {\n  KILL_SWITCH = true;\n};\n\nexport const checkKillSwitch = () => {\n  if (KILL_SWITCH) {\n    throw new Error(\"Algorithm was paused or killed\");\n  }\n};\n\nexport type StepFn = (list: Map<number, number>) => Promise<void>;\nexport const onSortStep = (\n  originalList: number[],\n  setRenderList: (l: number[]) => void,\n  setSelectedIdxs: (idxs: Set<number>) => void,\n  interval: number\n): StepFn => {\n  return async (list: Map<number, number>) => {\n    await delayMethod(() => {\n      setSelectedIdxs(new Set<number>([...list.keys()]));\n    }, interval);\n\n    const newList = insertEntries(list, originalList);\n\n    if (!listsAreEqual(newList, originalList)) {\n      originalList = await graduallyInsertEntries(\n        list,\n        originalList,\n        setRenderList,\n        setSelectedIdxs,\n        interval\n      );\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"module"}